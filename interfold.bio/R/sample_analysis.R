#' A null device for running plot functions without outputting graphics.
.nulldev <- function(file = nullfile(), ...) {
  type <- getOption("R.devices.nulldev", "pdf")
  do.call(type, args = list(nullfile()))
}

#' Function to get the centroids of samples transformed into the same model space across all blocks for a trained
#' multi-omics mixOmics (DIABLO) model. Prepares plots and raw data of consensus sample classification, which (for
#' some reason) isn't provided in the base package.
#'
#' @param diablo.trained Trained multi-omics mixOmics DIABLO model
#'
#' @return Simple object containing consensus data (as `consensus.summary`) and a ggplot plot of the distribution in the first two components (as `plot`)
#' @export
#'
#' @examples
#' \dontrun{
#' consensus.centroids <- get.block.centroids(diablo.trained.analysis, 20, 3)
#' print(consensus.centroids$plot)
#' }
get.block.centroids <- function(diablo.trained) {
  # Establish dimensionality
  block.count <- length(diablo.trained$X)
  sample.count <- length(diablo.trained$Y)
  comp.count <- diablo.trained$ncomp[1]

  # Perform the same analysis as the arrow plot -- sending graphics output to the null device
  .nulldev()

  # Set up the initial columns
  arrow <- mixOmics::plotArrow(diablo.trained)
  consensus <- data.frame(arrow$Block, arrow$group)
  consensus$sample <- rep(1:sample.count, block.count + 1)

  # Add component columns 1 at a time using arrow plots
  comp.col.names <- vector()
  for (comp in 1:comp.count) {
    comp.col.name <- sprintf("comp%i", comp)
    comp.col.names[comp] <- comp.col.name
    arrow <- mixOmics::plotArrow(diablo.trained, comp = c(1, comp))
    consensus[,comp.col.name] <- arrow$y
  }

  # Remove the outcome block
  consensus <- subset(consensus, !(arrow.Block == "Block: Y"))

  # Perform a group by on each sample, finding the centroid of each
  consensus.summary <- consensus %>% dplyr::group_by(sample, arrow.group) %>% dplyr::summarise_at(comp.col.names, mean)
  colnames(consensus.summary)[2] <- "label"

  dev.off()

  # Plot the consensus plot
  p <- ggplot2::ggplot(consensus.summary, ggplot2::aes(comp1, comp2, color = label))
  p <- p + ggplot2::geom_point() + ggplot2::stat_ellipse()

  # Return the consensus values
  return(list("consensus" = consensus.summary, "plot" = p))
}


#' Function to plot a single-omics sPLS-DA prediction projected into the model space. While confusion matrices of
#' predicted data can easily be obtained, there is no built-in function to plot the projection into the model space
#' and hence give a visualisation of the quality of the prediction. The plot will show the centroids of the classes
#' as large points, surrounded by the sample projection as small points, coloured according to class. A good prediction
#' will cluster each class around the appropriate centroid.
#'
#' @param prediction mixOmics sPLS-DA prediction object, generated by the `predict` method
#' @param classes.new Factor indicating the classes of the new data
#'
#' @return ggplot plot of the predicted data in the sPLS-DA model space
#' @export plot.predicted.projection
#'
#' @examples
#' \dontrun{
#' prediction.projection <- plot.predicted.projection(prediction.replicate.data, replicate.data.classes)
#' print(prediction.projection)
#' }
plot.predicted.projection <- function(prediction, classes.new) {
	variates <- as.data.frame(prediction$variates[,1:2])
	variates$label <- classes.new
	colnames(variates) <- c("Component1", "Component2", "label")

	p <- ggplot2::ggplot(variates, ggplot2::aes(x=Component1, y=Component2)) + ggplot2::geom_point(ggplot2::aes(color=label)) + ggplot2::theme_bw()

	classes.count <- length(levels(classes.new))
	pal <- scales::hue_pal()(classes.count)
	for (i in seq(1, classes.count)) {
		p <- p + annotate("point", x = prediction$centroids[i,1], y = prediction$centroids[i,2], color=pal[[i]], cex=6)
	}
	return(p)
}


#' Extract feature vs. feature association (mutual information) data for a multi-omics mixOmics (DIABLO) mode, and
#' plot this as a heatmap. This is the same data used to create the circos and network plots, but includes all
#' interactions for the top twenty features from each block.
#'
#' @param diablo Trained mixOmics multi-omics (DIABLO) model
#' @param block.count Number of blocks used in the model
#'
#' @return Matrix including the association of all selected features across all blocks. E.g. for a three block
#' multi-omic model, this will include the top 20 features from each block, and so return a 60x60 covariance matrix
#' @export
#'
#' @examples
#' \dontrun{
#' find.feature.associations(diablo.trained.analysis, 3)
#' }
find.feature.associations <- function(diablo.tuned, block.count) {
  # Extract the covariance matrix from the circosPlot function. Disable graphical output to avoid it being overwhelmed
	pdf(file = NULL)
	circos <- mixOmics::circosPlot(diablo.tuned, cutoff = 0.7, line = TRUE, size.labels = 1.5)
	dev.off()

	# Find the top factors across all blocks
	selected.factors <- list()
  for (i in 1:block.count) {
    dev.new(width = 3000, height = 3000, unit = "px")
    loadings <- mixOmics::plotLoadings(diablo.tuned, block=i, comp = 1, contrib = 'max', method = 'median', ndisplay=20)
    dev.off()
    selected.factors <- c(selected.factors, rownames(loadings))
  }

	# Filter the covariance matrix for the top factors
	circos.selected <- circos[rownames(circos) %in% selected.factors, colnames(circos) %in% selected.factors]
	diag(circos.selected) <- 1

	# Prepare dendrograms
	circos.selected.long <- reshape2::melt(circos.selected)
	circos.dendro <- stats::as.dendrogram(hclust(d = dist(x = circos.selected)))
	dendro.plot <- ggdendro::ggdendrogram(data = circos.dendro, rotate = TRUE)
	dendro.plot <- dendro.plot + ggplot2::theme(axis.text.y = element_blank())

	# Order the covariance matrix according to clustering in the dendrograms
	circos.order <- stats::order.dendrogram(circos.dendro)
	circos.selected.long$Var1 <- factor(x = circos.selected.long$Var1,
		levels = rownames(circos.selected)[circos.order],
		ordered = TRUE)
	circos.selected.long$Var2 <- factor(x = circos.selected.long$Var2,
		levels = rownames(circos.selected)[circos.order],
		ordered = TRUE)

	# Prepare the ordered heatmap plot
	heatmap.plot <- ggplot2::ggplot(data = circos.selected.long, ggplot2::aes(x = Var1, y = Var2)) +
	  ggplot2::geom_tile(ggplot2::aes(fill = value)) +
	  viridis::scale_fill_viridis(option="plasma") +
	  ggplot2::theme(legend.position = "top")

	# Make the plot
	grDevices::windows()
	grid::grid.newpage()
	print(heatmap.plot, vp = grid::viewport(x = 0.4, y = 0.5, width = 0.8, height = 1.0))
	print(dendro.plot, vp = grid::viewport(x = 0.90, y = 0.465, width = 0.2, height = 0.99))

	# Return the covariance matrix
	return(circos.selected)
}


.order.circos.selected <- function(circos.selected, circos.order) {
	circos.order.vars <- rownames(circos.selected)[circos.order]
	circos.ordered <- circos.selected[match(rownames(circos.selected), circos.order.vars), match(colnames(circos.selected), circos.order.vars)]
	return(circos.ordered)
}

#' Perform a permanova significance testing using the adonis function (from vegan) upon consensus classes, as returned
#' from the get.block.centroids method. Limited to first two components.
#'
#' @param consensus.summary Consensus summary as generated by get.block.centroids
#'
#' @return Measurement of p-value for separation of clusters
#' @export
permanova.clusters <- function(consensus.summary) {
	consensus.points <- data.frame(consensus.summary$comp1, consensus.summary$comp2)
	return(vegan::adonis(consensus.points ~ sample(consensus.summary$arrow.group), method='euclidean'))
}
