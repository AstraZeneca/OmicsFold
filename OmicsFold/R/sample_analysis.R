#' A null device for running plot functions without outputting graphics.
.nulldev <- function(file = nullfile(), ...) {
  type <- getOption("R.devices.nulldev", "pdf")
  do.call(type, args = list(nullfile()))
}

#' Get block centroids for a DIABLO model
#'
#' @description
#' Function to get the centroids of samples transformed into the same model
#' space across all blocks for a trained multi-omics mixOmics (DIABLO) model.
#' Prepares plots and raw data of consensus sample classification, which (for
#' some reason) isn't provided in the base package.
#'
#' @param diablo.trained Trained multi-omics mixOmics DIABLO model.
#'
#' @return Simple object containing consensus data (as `consensus.summary`) and
#' a ggplot plot of the distribution in the first two components (as `plot`).
#' @export
#'
#' @examples
#' \dontrun{
#' consensus.centroids <- get.block.centroids(diablo.trained.analysis, 20, 3)
#' print(consensus.centroids$plot)
#' }
get.block.centroids <- function(diablo.trained) {
  # Establish dimensionality
  block.count <- length(diablo.trained$X)
  sample.count <- length(diablo.trained$Y)
  comp.count <- diablo.trained$ncomp[1]

  # Perform the same analysis as the arrow plot -- sending graphics output to
  # the null device
  .nulldev()

  # Set up the initial columns
  arrow <- mixOmics::plotArrow(diablo.trained)
  consensus <- data.frame(arrow$Block, arrow$group)
  consensus$sample <- rep(1:sample.count, block.count + 1)

  # Add component columns 1 at a time using arrow plots
  comp.col.names <- vector()
  for (comp in 1:comp.count) {
    comp.col.name <- sprintf("comp%i", comp)
    comp.col.names[comp] <- comp.col.name
    arrow <- mixOmics::plotArrow(diablo.trained, comp = c(1, comp))
    consensus[,comp.col.name] <- arrow$y
  }

  # Remove the outcome block
  consensus <- subset(consensus, !(arrow.Block == "Block: Y"))

  # Perform a group by on each sample, finding the centroid of each
  consensus.summary <- consensus %>%
      dplyr::group_by(sample, arrow.group) %>%
      dplyr::summarise_at(comp.col.names, mean)
  colnames(consensus.summary)[2] <- "label"

  dev.off()

  # Plot the consensus plot
  p <- ggplot2::ggplot(consensus.summary,
                       ggplot2::aes(comp1, comp2, color = label))
  p <- p + ggplot2::geom_point() + ggplot2::stat_ellipse()

  # Return the consensus values
  return(list("consensus" = consensus.summary, "plot" = p))
}


#' Plot projections for a prediction result
#'
#' @description
#' Function to plot a single-omics sPLS-DA prediction projected into the model
#' space. While confusion matrices of predicted data can easily be obtained,
#' there is no built-in function to plot the projection into the model space and
#' hence give a visualisation of the quality of the prediction. The plot will
#' show the centroids of the classes as large points, surrounded by the sample
#' projection as small points, coloured according to class. A good prediction
#' will cluster each class around the appropriate centroid.
#'
#' @param prediction mixOmics sPLS-DA prediction object, generated by the
#' `predict` method.
#' @param classes.new Factor indicating the classes of the new data.
#'
#' @return ggplot plot of the predicted data in the sPLS-DA model space.
#' @export plot.predicted.projection
#'
#' @examples
#' \dontrun{
#' prediction.projection <- plot.predicted.projection(prediction.replicate.data, replicate.data.classes)
#' print(prediction.projection)
#' }
plot.predicted.projection <- function(prediction, classes.new) {
  variates <- as.data.frame(prediction$variates[,1:2])
  variates$label <- classes.new
  colnames(variates) <- c("Component1", "Component2", "label")

  p <- ggplot2::ggplot(variates, ggplot2::aes(x=Component1, y=Component2)) +
       ggplot2::geom_point(ggplot2::aes(color=label)) +
       ggplot2::theme_bw()

  classes.count <- length(levels(classes.new))
  pal <- scales::hue_pal()(classes.count)
  for (i in seq(1, classes.count)) {
    p <- p + annotate("point", x = prediction$centroids[i,1],
                      y = prediction$centroids[i,2], color = pal[[i]], cex = 6)
  }
  return(p)
}

#' Extract and plot feature associations in a DIABLO model
#'
#' @description
#' Extract feature vs. feature association (mutual information) data for a
#' multi-omics mixOmics (DIABLO) model, and plot this as a heatmap. This is the
#' same data used to create the circos and network plots, but includes all
#' interactions for the top features according to blockrank scores
#'
#' @param diablo.tuned Trained mixOmics multi-omics (DIABLO) model.
#' @param nscores Number of top features to select
#'
#' @return Matrix including the associations of top selected features according 
#' to blockrank scores
#'
#' @export
#'
#' @examples
#' \dontrun{
#' blockrank.find.feature.associations(diablo.tuned, 50)
#' }

blockrank.find.feature.associations <- function(diablo.tuned, nscores) {
  
   #Extract the covariance matrix from the circosPlot function. Disable
   #graphical output to avoid it being overwhelmed
   pdf(file = NULL)
   circos <- mixOmics::circosPlot(diablo.tuned, cutoff = 0.7,
                                 line = TRUE, size.labels = 1.5)
   dev.off()

   #find top features across all blocks by ranking blockrank scores high to low
  
   #run blockrank
   blockrank.i <- blockrank.diablo(diablo.tuned)
    
   #compile blockrank results
   plot.data <- vector(mode = "list", length = length(blockrank.i))
    for (q in seq_along(blockrank.i)){
      block <- names(blockrank.i)[q]
      feature <- names(blockrank.i[[q]])
      blockrank.score <- blockrank.i[[q]]
      plot.data[[q]] <- data.frame(block, feature, blockrank.score)
    }
   plot.data <- bind_rows(plot.data)
   plot.data <- arrange(plot.data, desc(blockrank.score))
    
   #filter to desired number of features
   plot.data <- head(plot.data,n=nscores)
    
   #Find the top factors across all blocks
   selected.features <- plot.data$feature
    
  
  
   #Filter the covariance matrix for the top features based on blockrank scores
   circos.selected <- circos[rownames(circos) %in% selected.features,
                            colnames(circos) %in% selected.features]
   diag(circos.selected) <- 1
  
   #Prepare dendrograms
   circos.selected.long <- reshape2::melt(circos.selected)
   circos.dendro <- stats::as.dendrogram(hclust(d = dist(x = circos.selected)))
   dendro.plot <- ggdendro::ggdendrogram(data = circos.dendro, rotate = TRUE)
   dendro.plot <- dendro.plot + ggplot2::theme(axis.text.y = element_blank())
  
   #Order the covariance matrix according to clustering in the dendrograms
   circos.order <- stats::order.dendrogram(circos.dendro)
   circos.selected.long$Var1 <- factor(x = circos.selected.long$Var1,
                                      levels = rownames(circos.selected)[circos.order],
                                      ordered = TRUE)
   circos.selected.long$Var2 <- factor(x = circos.selected.long$Var2,
                                      levels = rownames(circos.selected)[circos.order],
                                      ordered = TRUE)
  
   #Prepare the ordered heatmap plot
   heatmap.plot <- ggplot2::ggplot(data = circos.selected.long,
                                  ggplot2::aes(x = Var1, y = Var2)) +
    ggplot2::geom_tile(ggplot2::aes(fill = value)) +
    viridis::scale_fill_viridis(option="plasma") +
    ggplot2::theme(legend.position = "top")
  
   #Make the plot
   grid::grid.newpage()
   print(heatmap.plot,
        vp = grid::viewport(x = 0.4, y = 0.5, width = 0.8, height = 1.0))
   print(dendro.plot,
        vp = grid::viewport(x = 0.90, y = 0.465, width = 0.2, height = 0.99))
  
   # Return the covariance matrix
   return(circos.selected)
}


#' Filter feature association matrix by correlation cutoff and reformat with
#' respect to features of interest for feature interaction network visualization in Cystoscape
#'
#' @description
#' Filter feature association matrix to remove associations that do not meet a given correlation cut off.
#' Manipulate feature association matrix to identify associations with 
#' features of interest to use as source nodes in Cytoscape network visualization. Removes intrablock associations.
#'
#' @param diablo.tuned Trained mixOmics multi-omics (DIABLO) model
#' @param associations Matrix including the associations of top selected features according to blockrank scores
#' @param source_node_features List of features of interest to use as source nodes in final network
#' @param cutoff Correlation cut off to filter association matrix by
#'
#' @return Dataframe describing correlations with features of interest and their associated blocks
#'
#' @export
#'
#' @examples
#' \dontrun{
#' filter_network(diablo.model, associations, c("Alistipes_putredinis", "Streptococcus_parasanguinis"), 0.5)
#' }

filter_network <- function(diablo.model, associations, source_node_features, cutoff){

#generate block names for all features in model
feature_block_names <- data.frame()
number_of_blocks <- length(diablo.model$loadings)-1
for (i in 1:number_of_blocks) {
  active.block <- diablo.model$loadings[[i]]
  active.block.names <- data.frame(rownames(active.block), names(diablo.model$loadings[i]))
  feature_block_names <- rbind(feature_block_names, active.block.names)
}

#identify blocks for top features
block_association <- feature_block_names[feature_block_names$rownames.active.block. %in% rownames(associations),]$names.diablo.model.loadings.i..

#export network file with correlation cut off
network <- export.matrix.as.network(associations, cutoff= cutoff, 
                                    filename = "network_test.csv", block.association = block_association)

#subset features of interest with correct blocks for target nodes
network_subset <- network[network$feature.1 %in% 
                            source_node_features | network$feature.2 %in% source_node_features,]

#convert data into appropriate format for visualization of network in cytoscape 

#conditionally switch values where the target node is in the first column
network_subset_switch <-network_subset
names(network_subset_switch)[1]<-"target_node"
names(network_subset_switch)[2]<-"source_node"
names(network_subset_switch)[4]<-"source_node_block"
#identify which rows need to be switched and do not have the correct source node
i <- which(!network_subset_switch$source_node %in% source_node_features)
#create vectors with new row values
new_source <- network_subset_switch$target_node[i]
new_target <- network_subset_switch$source_node[i]
#change row values for the rows that need to be switched
network_subset_switch$source_node[i] <- new_source
network_subset_switch$target_node[i] <- new_target
#merge in block names for target nodes
network_subset_merged <- merge(network_subset_switch, feature_block_names, by.x="target_node", by.y="rownames.active.block.", all.x = TRUE)
names(network_subset_merged)[5] <- "target_node_block"

#remove intrablock connections
'%!in%' <- function(x,y)!('%in%'(x,y))
#create primary key for each id
network_subset_merged$id <- rownames(network_subset_merged)
#identify intrablock connections to remove
network_to_remove <- network_subset_merged[network_subset_merged$source_node_block == network_subset_merged$target_node_block 
              & network_subset_merged$target_node %!in% source_node_features,]
#remove the unwanted intrablock connections
network_filtered <- network_subset_merged[network_subset_merged$id %!in% network_to_remove$id,]
#remove primary key
network_filtered$id <- NULL

return(network_filtered)

}


.order.circos.selected <- function(circos.selected, circos.order) {
  circos.order.vars <- rownames(circos.selected)[circos.order]
  circos.ordered <-
      circos.selected[match(rownames(circos.selected), circos.order.vars),
                      match(colnames(circos.selected), circos.order.vars)]
  return(circos.ordered)
}

#' Perform a permanova signficance test
#'
#' @description
#' Perform a permanova significance testing using the adonis function (from
#' vegan) upon consensus classes, as returned from the get.block.centroids
#' method. Limited to first two components.
#'
#' @param consensus.summary Consensus summary as generated by
#' get.block.centroids().
#'
#' @return Measurement of p-value for separation of clusters.
#' @export
permanova.clusters <- function(consensus.summary) {
  consensus.points <- data.frame(consensus.summary$comp1,
                                 consensus.summary$comp2)
  return(vegan::adonis(consensus.points ~ sample(consensus.summary$arrow.group),
                       method='euclidean'))
}
